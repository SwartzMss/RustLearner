fn main() {
    println!("Hello, world!");

    // 变量只有在初始化后才能被使用
    // let x: i32 = 0; // 未初始化，但被使用
    // let _y: i32; // 未初始化，也未被使用 不被使用的话 就用_ 开头就行
    // println!("x is equal to {}", x); 

    // 可以使用 mut 将变量标记为可变
    // let mut x = 1; 默认都是不可变的，如果需要改变的话 需要显示的指定mut
    // x += 2; 
    // println!("x = {}", x); 

    // 作用域是一个变量在程序中能够保持合法的范围
    // let x: i32 = 10;
    // {
    //     let y: i32 = 5;
    //     println!("x 的值是 {}, y 的值是 {}", x, y);
    // }
    // println!("x 的值是 {}, y 的值是 {}", x); 

    // 若后面的变量声明的名称和之前的变量相同，则我们说：第一个变量被第二个同名变量遮蔽了( shadowing )
    // let x: i32 = 5;
    // {
    //     let x = 12;
    //     assert_eq!(x, 12);
    // }
    // assert_eq!(x, 5);
    // let x = 42;
    // println!("{}", x); // 输出 "42".

    // 我们可以将 let 跟一个模式一起使用来解构一个元组，最终将它解构为多个独立的变量
    // let (mut x, y) = (1, 2);
    // x += 2;
    // assert_eq!(x, 3);
    // assert_eq!(y, 2);

    //你可以在赋值语句的左式中使用元组、切片或结构体进行匹配赋值
    let (x, y);
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    // 填空，让代码工作
    assert_eq!([x,y], [3,2]);
}
